# Compiler plugin to generate serialization code for classes

* **Type**: Design proposal
* **Status**: Submitted
* **Prototype**: Partially implemented, shipped separately

## Feeback

Original proposal and its discussion are held in this [forum thread](https://discuss.kotlinlang.org/t/kotlin-serialization/2063).

## Synopsis

Kotlin, starting from 1.2, offers support for multiplatfrom projects, and there is a need in multiplatform library for serialization.
Since reflection is not available in common code, auto-generated code can help to reduce big amount of boilerplate which users need to write to serialize and deserialize classes.

This proposal describes how compiler plugin can be used for this task, and offers a convention between compiler and runtime library [kotlinx.serialziation](https://github.com/Kotlin/kotlinx.serialization/).

## Problems this proposal tries to solve

1. Platform serialization mechanisms not always work well with Kotlin: [KT-7939](https://youtrack.jetbrains.com/issue/KT-7939), [KT-23998](https://youtrack.jetbrains.com/issue/KT-23998)
1. Reflection API is not available in Kotlin/JS and Kotlin/Native, so it is impossible to use only runtime-based solution.
1. Kapt is not supported by Kotlin/JS and Kotlin/Native, so it is impossible to use annotation processing.
1. Side code generators does not work well with incremental compilation and it is non-trivial to include them as build phase.
1. kotlinx.serialization alone requires a lot of boilerplate code.

## API overview

At a glance, kotlinx.serialziation tries to provide abstraction over different serialziation formats by exposing API which can encode primitive types one-by-one. Compiler plugin can make proper usage of this API, since it knows everything about which fields a class consists of. In somewhat, this plugin could be equivivalent to [parcelize plugin](android-parcelable.md), but for slighlty bigger API.

> Source code of API given here is not full and contains only declarations which need to be stable and discoverable by code generator. Other parts of library and additional interfaces methods are not connected with plugin and therefore are not included here.

### Serializer interfaces

Following interfaces could be provided in runtime part of the library to be implemented by serializable class:

```kotlin
interface SerializationStrategy<in T> {
    fun serialize(output: Encoder, obj : T)
}

interface DeserializationStrategy<out T> {
    fun deserialize(input: Decoder): T
}

interface KSerializer<T>: SerializationStrategy<T>, DeserializationStrategy<T> {
    val serialClassDesc: SerialDescriptor
}
```

`KSerializer<T>` is an entity that knows how to decompose class `T` and feed its primitives to encoder, and vice versa. Its implementation should be written by user, or, in this case, generated by compiler plugin.

### Descriptor of serializable entity

> TBD

### Encoder interfaces

Encoder incapluslates knowledge about output format and storage. This interface is provided by serialization format in runtime and should be used by serializer. For perfomance and type-safe reasons, encoder interface contains one method for each primitive type:

```kotlin
interface Encoder {
    fun encodeValue(value: Any)

    fun encodeNotNullMark()
    fun encodeNull()

    fun encodeNullableValue(value: Any?)
    fun encodeUnit()
    fun encodeBoolean(value: Boolean)
    fun encodeByte(value: Byte)
    fun encodeShort(value: Short)
    fun encodeInt(value: Int)
    fun encodeLong(value: Long)
    fun encodeFloat(value: Float)
    fun encodeDouble(value: Double)
    fun encodeChar(value: Char)
    fun encodeString(value: String)

    fun <T : Enum<T>> encodeEnum(value: T)

    fun <T : Any?> encodeSerializable(strategy: SerializationStrategy<T>, value: T) {
        strategy.serialize(this, value)
    }
}
```

However, this interface is not able to write structured data like classes or collections, because there is no way to express delimeters and metadata about structure itself. 
`StructureEncoder` serves this purpose. It extends `Encoder` interface with additional methods which accept structure descriptor and current position in structure.

```kotlin
interface Encoder {
    // in addition to previous methods
    fun beginStructure(desc: SerialDescriptor, vararg typeArgumentsSerializers: KSerializer<*>): StructuredEncoder

    fun beginCollection(desc: SerialDescriptor, collectionSize: Int, vararg typeArgumentsSerializers: KSerializer<*>): StructuredEncoder
}

interface StructureEncoder: Encoder {
    // delimeter
    fun endStructure(desc: SerialDescriptor)

    fun encodeElementValue(desc: SerialDescriptor, index: Int, value: Any)
    fun encodeNullableElementValue(desc: SerialDescriptor, index: Int, value: Any?)

    fun encodeUnitElement(desc: SerialDescriptor, index: Int)
    fun encodeBooleanElement(desc: SerialDescriptor, index: Int, value: Boolean)
    fun encodeByteElement(desc: SerialDescriptor, index: Int, value: Byte)
    fun encodeShortElement(desc: SerialDescriptor, index: Int, value: Short)
    fun encodeIntElement(desc: SerialDescriptor, index: Int, value: Int)
    fun encodeLongElement(desc: SerialDescriptor, index: Int, value: Long)
    fun encodeFloatElement(desc: SerialDescriptor, index: Int, value: Float)
    fun encodeDoubleElement(desc: SerialDescriptor, index: Int, value: Double)
    fun encodeCharElement(desc: SerialDescriptor, index: Int, value: Char)
    fun encodeStringElement(desc: SerialDescriptor, index: Int, value: String)

    fun <T : Enum<T>> encodeEnumElement(desc: SerialDescriptor, index: Int, enumClass: KClass<T>, value: T)

    fun <T : Enum<T>> encodeSerializableElement(desc: SerialDescriptor, index: Int, strategy: SerializationStrategy<T>, value: T)
}
```

### Decoder interfaces

Decoder, as encoder, encapsulates knowlege about format, and
provides primitive values when deserializer asks for them. 
`Decoder` interface will be precisely the opposite of `Encoder`:

```kotlin
interface Decoder {
    // returns true if the following value is not null, false if not null
    fun decodeNotNullMark(): Boolean
    // consumes null, returns null, will be called when decodeNotNullMark() is false
    fun decodeNull(): Nothing? 

    fun decodeValue(): Any

    fun decodeNullable(): Any?
    fun decodeUnit()
    fun decodeBoolean(): Boolean
    fun decodeByte(): Byte
    fun decodeShort(): Short
    fun decodeInt(): Int
    fun decodeLong(): Long
    fun decodeFloat(): Float
    fun decodeDouble(): Double
    fun decodeChar(): Char
    fun decodeString(): String

    fun <T : Enum<T>> decodeEnum(enumCreator: EnumCreator<T>): T

    fun <T : Any?> decodeSerializableValue(strategy: DeserializationStrategy<T>): T = strategy.deserialize(this)
}
```

However, an opposite interface for `StructureEncoder` would not be very useful. Primitives in read stream can go in arbitrary order, and besides opposite to `encodeXxxElementValue` methods there is a `readElement` method, which should be called to determine current position in structure.

```kotlin
interface Decoder {
    fun beginStructure(desc: SerialDescriptor, vararg typeParams: KSerializer<*>): StructureDecoder
    fun beginCollection(desc: SerialDescriptor, vararg typeParams: KSerializer<*>): StructureDecoder
}

interface StructureDecoder: Decoder {
    fun endStructure(desc: SerialDescriptor)

    // decodeElement results
    companion object {
        // end of input
        const val READ_DONE = -1
        // decoder sure that elements go in order, no need to call decodeElement
        const val READ_ALL = -2
    }

    // returns either index or one of READ_XXX constants
    fun decodeElement(desc: SerialDescriptor): Int

    fun decodeElementValue(desc: SerialDescriptor, index: Int): Any

    fun decodeNullableElement(desc: SerialDescriptor, index: Int): Any?
    fun decodeUnitElement(desc: SerialDescriptor, index: Int)
    fun decodeBooleanElement(desc: SerialDescriptor, index: Int): Boolean
    fun decodeByteElement(desc: SerialDescriptor, index: Int): Byte
    fun decodeShortElement(desc: SerialDescriptor, index: Int): Short
    fun decodeIntElement(desc: SerialDescriptor, index: Int): Int
    fun decodeLongElement(desc: SerialDescriptor, index: Int): Long
    fun decodeFloatElement(desc: SerialDescriptor, index: Int): Float
    fun decodeDoubleElement(desc: SerialDescriptor, index: Int): Double
    fun decodeCharElement(desc: SerialDescriptor, index: Int): Char
    fun decodeStringElement(desc: SerialDescriptor, index: Int): String

    fun <T : Enum<T>> decodeEnumElement(desc: SerialDescriptor, index: Int, enumCreator: EnumCreator<T>): T

    fun <T : Any?> decodeSerializableElement(desc: SerialDescriptor, index: Int, loader: DeserializationStrategy<T>): T
}
``` 

## Code generation strategy

### Requirements

First, let's narrow the scope for now and say that only class can be serializable, not interface, annotation or object.

If compiler plugin has complete control over the class, then it can automatically implement `KSerializer<T>` for class `T` if its every primary constructor parameter is `val` or `var` – since parameters which are not properties are impossible to save for restoring later. In this case (we called it **internal** serialization), plugin injects special synthetic constructor into the class to be able to correctly initialize its private and/or body properties. Delegated properties are not supported (they can be safely excluded from the process).

If plugin was asked to generate `KSerializer<T>` without modifying `T` (**external** serialization), then class `T` must have accessible primary constructor. Following properties would be impossible to initialize correctly after deserialization and therefore they are skipped:

- private/protected body vals and vars (internal too if `T` located in other module)
- public body vals

### Layout of synthetic classes and methods

In case of internal serialization, which is expressed by `@Serializable` annotation on class `T`, compiler plugin should generate:

1. Synthetic constructor for `T` which initializes all state properties including private and body ones.
1. Nested class with special name `$serializer` which implements `KSerializer<T>`. If `T` has no type arguments, this class would be a singleton. If it has, e.g. `T = T<T0, T1...>` then its constructor will have properties `KSerializer<T0>, KSerializer<T1>, ...`.
2. Method `T.Companion.serializer()` which returns `$serializer`. If `T` has type arguments (`T = T<T0, T1...>`) then this method will have arguments `KSerializer<T0>, KSerializer<T1>, ...`.
3. Implementation method `$serializer.serialize(Encoder, T)` which feeds T into Encoder by making consequent calls to `beginStructure`, `encodeXxxElementValue` several times, `endStructure`.
4. Implementation method `$serializer.deserialize(Decoder): T` which collects variables from Decoder by making calls to `beginStructure`, `decodeElement`, `decodeXxxElementValue` with correct index until end of input, `endStructure`. Then it validates that all primitives were read and constructs T from collected primitives. 
5. Implementation property `$serializer.serialClassDesc` which holds metadata about class.

In case of external serialization, expressed by `@Serializer(forClass=...)` only last three items are done. In `deserialize`, plugin calls primary constructor of class and then all available property setters.

User should be able to provide custom implementation for `serialize` and `deserialize` just by writing functions with proper signature by hand, in this case compiler plugin will skip corresponding steps.

### Resolving and lookup

During generation of implementation methods, compiler plugin needs to chose concrete method to call from group of `(en|de)codeXxxElement`. If current property has primitive non-nullable type, like `Int` or `String`, then it is possible to call matched by signature method directly. If it has nullable and/or complex `E`, compiler plugin uses following rules to find serializer for `E` and then call `(en|de)codeSerializableElement`:

1. If current property annotated with `@Serializable(with=T::class)`, construct and use instance of `T` as serializer for `E`.
1. If `E` is a type parameter, use corresponding serializer passed in constructor.
1. If `E` is a primitive type (boxed for some reason), use corresponding pre-defined serializer from runtime library.
2. If `E = V?` – nullable type, find serializer for `V` and adapt it with `NullableSerializer` from runtime library.
1. If `E` is on of supported types from standard library: `Array, (Mutable)List, ArrayList, (Mutable)Set, LinkedHashSet, (Mutable)Map, LinkedHashMap, Pair, Triple` then find serializer for its generic arguments and construct corresponding serializer from runtime library.
1. If `E` is a user type annotated with `@Serializable`, construct and use its `$serializer`.
1. If `E` is a user type annotated with `@Serializable(with=T::class)`, construct and use instance of `T` as serializer.
1. If none of the previous rules apply, report a warning and use untyped `writeElementValue(SerialDescriptor, index, Any)` function.

### Tuning generated code

To be more flexible and support various use-cases, plugin have to respect following annotations:

* `@SerialName`, which alters name of property or class written to metadata in descriptor.
* `@Optional`, which allows property to be absent in the decoder input. Requires default value on property. By default, all properties are required (even with default values).
* `@Transient`, which makes property invisible for plugin.
* `@SerialInfo`, which allows to create custom annotations with metadata and record them in the descriptor.

## Open for discussion issues

* Currently `SerializationStrategy + DeserializationStrategy` interface named `KSerializer`, because we have `@Serializer` annotation for generate external serializer. Since it is not used very often, probably it is good idea to make interface `Serializer` and rename annotation?
* It may be not clear that `Serializer` can do both serialization and deserialization. Maybe we need better name, like `Mapper`?
* Should user have an ability to manipulate layout and order of calls to encoder from generated code? [#121](https://github.com/Kotlin/kotlinx.serialization/issues/121)
* Should `@Optional` annotation be applied automatically when property has default value? [#19](https://github.com/Kotlin/kotlinx.serialization/issues/19)
* Should primitive arrays (ByteArray etc) be treated specially by plugin or should it be burden of format implementation to handle them? [#52](https://github.com/Kotlin/kotlinx.serialization/issues/52)

## Future work

* Implement saving class *shema*, not only the instance of class.
* Improve serialization of class hierarchies, known as polymorphic. Add better support for `sealed` classes.
* Implement serialization/deserialization of interfaces.
* Serializable coroutines and continuations.
