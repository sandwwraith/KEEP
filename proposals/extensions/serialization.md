# Compiler plugin to generate serialization code for classes

* **Type**: Design proposal
* **Status**: Submitted
* **Prototype**: Partially implemented, shipped separately

## Feeback

Original proposal and its discussion are held in this [forum thread](https://discuss.kotlinlang.org/t/kotlin-serialization/2063).

## Synopsis

Kotlin, starting from 1.2, offers support for multiplatform projects, and there is a need in multiplatform library for serialization.
Since reflection is not available in common code, auto-generated code can help to reduce big amount of boilerplate which users need to write to serialize and deserialize classes.

This proposal describes how compiler plugin can be used for this task, and offers a convention between compiler and runtime library [kotlinx.serialziation](https://github.com/Kotlin/kotlinx.serialization/).

## Problems this proposal tries to solve

1. Platform serialization mechanisms not always work well with Kotlin: [KT-7939](https://youtrack.jetbrains.com/issue/KT-7939), [KT-23998](https://youtrack.jetbrains.com/issue/KT-23998)
1. Reflection API is not available in Kotlin/JS and Kotlin/Native, so it is impossible to use only runtime-based solution.
1. Kapt is not supported by Kotlin/JS and Kotlin/Native, so it is impossible to use annotation processing.
1. Side code generators does not work well with incremental compilation and it is non-trivial to include them as build phase.
1. kotlinx.serialization alone requires a lot of boilerplate code.

## Core API overview

At a glance, kotlinx.serialziation tries to provide abstraction over different serialization formats by exposing API which can encode primitive types one-by-one. Compiler plugin can make proper usage of this API, since it knows everything about which fields a class consists of. In somewhat, this plugin could be equivalent to [parcelize plugin](android-parcelable.md), but for slightly bigger API.

> Source code of API given here is not full and contains only declarations which need to be stable and discoverable by code generator. Other parts of library and additional interfaces methods are not connected with plugin and therefore are not included here.

### Serializer interfaces

Following interfaces are provided in the library to be implemented by serializer of particular class:

```kotlin
interface SerializationStrategy<in T> {
    fun serialize(output: Encoder, obj : T)
    val descriptor: SerialDescriptor
}

interface DeserializationStrategy<out T> {
    fun deserialize(input: Decoder): T
    val descriptor: SerialDescriptor
}

interface Serializer<T>: SerializationStrategy<T>, DeserializationStrategy<T> {
    override val descriptor: SerialDescriptor
}
```

`Serializer<T>` is an entity that knows how to decompose class `T` and feed its primitives to some encoding/saving mechanism, and vice versa. Its implementation should be written by user, or, in this case, generated by compiler plugin. Note, that it should not know anything about output or storage format.

> In documentation for this framework, we are using words "serializer" and "serialization" widely. Please pay special attention that under this words, in most of cases, we assume capable entity or process of both serialization (saving, decomposing) and deserialization (loading, composing) – just because there is no good word for "both serialization and deserialization same time".

### Descriptor of serializable entity

Because reflection can't be used in this library, there is a need for some data structure sufficient to hold simple metadata about serializable class – to be able to retrieve information needed for saving both class and its schema, e.g. class name, properties names and types and so on. Interface for this data structure is provided by the library and called `SerialDescriptor`. It _describes_ **serializable entity**, or just **entity**, which has **elements**. 

```kotlin
interface SerialDescriptor {
    val name: String
    val kind: SerialKind

    fun getElementName(index: Int): String
    fun getElementIndex(name: String): Int

    fun getEntityAnnotations(): List<Annotation>
    fun getElementAnnotations(index: Int): List<Annotation>

    val elementsCount: Int

    fun getElementDescriptor(index: Int): SerialDescriptor

    val isNullable: Boolean
    fun isElementOptional(index: Int): Boolean
}
```

Corresponding documentation and usage of the interface are out of scope of this document; it is presented here to introduce general concept of serializable entity metadata. This interface can (and should) also be implemented by compiler plugin for given class, because `Serializer<T>` has reference on `SerialDescriptor`.

Note, that we specially don't limit ourselves to "class and properties" terminology, because not only classes can be described with this data structure. `SerialKind` can give a clue on which kinds of entities can be serialized:

```kotlin
sealed class SerialKind

sealed class PrimitiveKind: SerialKind() {
    object INT : PrimitiveKind()
    object STRING: PrimitiveKind()
    // other primitives cut out for shortness
}

sealed class StructureKind: SerialKind() {
    object CLASS: StructureKind()
    object LIST: StructureKind()
    object MAP: StructureKind()
}

sealed class UnionKind: SerialKind() {
    object OBJECT: UnionKind()
    object ENUM: UnionKind()
    object SEALED: UnionKind()
    object POLYMORPHIC: UnionKind()
}
```

Invariants of `SerialDescriptor` for each kind will be described in kind's documentation. Entities which does not have primitive kind are called **composite**. Referring to unions, sometimes their elements are also called **cases**.

### Encoder interfaces

Encoder encapsulates knowledge about output format and storage. This interface is provided by serialization format in runtime and should be used by serializer. For performance and type-safe reasons, encoder interface contains one method for each primitive type:

```kotlin
interface Encoder {
    fun encodeNotNullMark()
    fun encodeNull()

    fun encodeUnit()
    fun encodeBoolean(value: Boolean)
    fun encodeByte(value: Byte)
    fun encodeShort(value: Short)
    fun encodeInt(value: Int)
    fun encodeLong(value: Long)
    fun encodeFloat(value: Float)
    fun encodeDouble(value: Double)
    fun encodeChar(value: Char)
    fun encodeString(value: String)

    // although we don't classify enums as primitives in terms of kinds,
    // this function is provided as a shorthand.
    fun <E : Enum<E>> encodeEnum(value: E, enumDescriptor: SerialDescriptor)

    // can be defined as extension
    fun <T : Any?> encodeSerializable(strategy: SerializationStrategy<T>, value: T) {
        strategy.serialize(this, value)
    }
}
```

However, this interface is not able to write composite data like classes, collections or unions, because there is no way to express delimiters and metadata about entity itself. 
`CompositeEncoder` serves this purpose. It has similar to `Encoder` interface with methods which accept serializable descriptor and current position in structure or case in union. Note that it does not extend `Encoder` because once you've started to write structure, you're not allowed to write primitive values without indices.

```kotlin
interface Encoder {
    // in addition to previous methods
    fun beginEncodeComposite(desc: SerialDescriptor): CompositeEncoder
}

interface CompositeEncoder {
    // delimiter
    fun endEncodeComposite(desc: SerialDescriptor)

    fun encodeUnitElement(desc: SerialDescriptor, index: Int)
    fun encodeBooleanElement(desc: SerialDescriptor, index: Int, value: Boolean)
    fun encodeByteElement(desc: SerialDescriptor, index: Int, value: Byte)
    fun encodeShortElement(desc: SerialDescriptor, index: Int, value: Short)
    fun encodeIntElement(desc: SerialDescriptor, index: Int, value: Int)
    fun encodeLongElement(desc: SerialDescriptor, index: Int, value: Long)
    fun encodeFloatElement(desc: SerialDescriptor, index: Int, value: Float)
    fun encodeDoubleElement(desc: SerialDescriptor, index: Int, value: Double)
    fun encodeCharElement(desc: SerialDescriptor, index: Int, value: Char)
    fun encodeStringElement(desc: SerialDescriptor, index: Int, value: String)

    fun <E : Enum<E>> encodeEnumElement(desc: SerialDescriptor, index: Int, value: E, enumDescriptor: SerialDescriptor)

    fun <T> encodeSerializableElement(desc: SerialDescriptor, index: Int, strategy: SerializationStrategy<T>, value: T)
}
```

### Decoder interfaces

Decoder, as encoder, encapsulates knowledge about format, and
provides primitive values when deserializer asks for them. 
`Decoder` interface will be precisely the opposite of `Encoder`:

```kotlin
interface Decoder {
    // returns true if the following value is not null, false if not null
    fun decodeNotNullMark(): Boolean
    // consumes null, returns null, will be called when decodeNotNullMark() is false
    fun decodeNull(): Nothing?

    fun decodeUnit()
    fun decodeBoolean(): Boolean
    fun decodeByte(): Byte
    fun decodeShort(): Short
    fun decodeInt(): Int
    fun decodeLong(): Long
    fun decodeFloat(): Float
    fun decodeDouble(): Double
    fun decodeChar(): Char
    fun decodeString(): String

    // because there is no non-reflective version of `valueOf`, decoder
    // is asked for a particular index of enum instance
    fun <T : Enum<T>> decodeEnum(enumDescriptor: SerialDescriptor): Int

    // can be defined as extension
    fun <T : Any?> decodeSerializable(strategy: DeserializationStrategy<T>): T = strategy.deserialize(this)
}
```

However, an opposite interface for `ElementEncoder` would not be very useful. Primitives in read stream can go in arbitrary order, and besides opposite to `encodeXxxElement` methods there is a `decodeElementIndex` method, which should be called to determine current position in structure.

```kotlin
interface Decoder {
    fun beginDecodeComposite(desc: SerialDescriptor): CompositeDecoder
}

interface CompositeDecoder {
    fun endDecodeComposite(desc: SerialDescriptor)

    // decodeElementIndex results
    companion object {
        // end of input
        const val READ_DONE = -1
        // decoder sure that elements go in order, no need to call decodeElementIndex
        const val READ_ALL = -2
    }

    // returns either index or one of READ_XXX constants
    fun decodeElementIndex(desc: SerialDescriptor): Int

    fun decodeUnitElement(desc: SerialDescriptor, index: Int)
    fun decodeBooleanElement(desc: SerialDescriptor, index: Int): Boolean
    fun decodeByteElement(desc: SerialDescriptor, index: Int): Byte
    fun decodeShortElement(desc: SerialDescriptor, index: Int): Short
    fun decodeIntElement(desc: SerialDescriptor, index: Int): Int
    fun decodeLongElement(desc: SerialDescriptor, index: Int): Long
    fun decodeFloatElement(desc: SerialDescriptor, index: Int): Float
    fun decodeDoubleElement(desc: SerialDescriptor, index: Int): Double
    fun decodeCharElement(desc: SerialDescriptor, index: Int): Char
    fun decodeStringElement(desc: SerialDescriptor, index: Int): String

    fun <T : Enum<T>> decodeEnumElement(desc: SerialDescriptor, index: Int, enumDescriptor: SerialDescriptor): Int

    fun <T : Any?> decodeSerializableElement(desc: SerialDescriptor, index: Int, strategy: DeserializationStrategy<T>): T
}
```

## Code generation strategy

### Requirements

First, let's narrow the scope for now and say that only class or object can be serializable, not interface or annotation.

If compiler plugin has complete control over the class, then it can automatically implement `Serializer<T>` for class `T` if its every primary constructor parameter is `val` or `var` – since parameters which are not properties are impossible to save for restoring later. In this case (we called it **internal** serialization), plugin injects special synthetic constructor into the class to be able to correctly initialize its private and/or body properties. Delegated properties are not supported (they can be safely excluded from the process).

If plugin was asked to generate `Serializer<T>` without modifying `T` (**external** serialization), then class `T` must have accessible primary constructor. Following properties would be impossible to initialize correctly after deserialization and therefore they are skipped:

- private/protected body vals and vars (internal too if `T` located in other module)
- public body vals

### Layout of synthetic classes and methods for structures

In case of internal serialization, which is expressed by `@Serializable` annotation on class `T`, compiler plugin should generate:

1. Synthetic constructor for `T` which initializes all state properties including private and body ones.
1. Nested class with special name `$serializer` which implements `Serializer<T>`. If `T` has no type arguments, this class would be a singleton. If it has, e.g. `T = T<T0, T1...>` then its constructor will have properties `Serializer<T0>, Serializer<T1>, ...`.
5. Implementation property `$serializer.descriptor` which holds metadata about class.
2. Method `T.Companion.serializer()` which returns `$serializer`. If `T` has type arguments (`T = T<T0, T1...>`) then this method will have arguments `Serializer<T0>, Serializer<T1>, ...`. If companion is not declared on class, its default body also will be generated.
3. Implementation method `$serializer.serialize(Encoder, T)` which feeds T into Encoder by making consequent calls to `beginStructure`, `encodeXxxElement` several times, `endStructure`.
4. Implementation method `$serializer.deserialize(Decoder): T` which collects variables from Decoder by making calls to `beginStructure`, `decodeElementIndex`, `decodeXxxElement` with correct index until end of input, `endStructure`. Then it validates that all primitives were read and constructs T from collected primitives.

In case of external serialization, expressed by `@ExternalSerializer(forClass=...)` only last three items are done. In `deserialize`, plugin calls primary constructor of class and then all available property setters.

User should be able to provide custom implementation for `serialize` and `deserialize` just by writing functions with proper signature by hand, in this case compiler plugin will skip corresponding steps.

### Layout for unions

For tagged unions, plugin would do the same thing, except bodies of `serialize` and `deserialize` methods: only one `encodeSerializableElement` method is called. Index argument represents which particular instance is being serialized, and serializer for that instance is passed. _sealed classes_ serialization from this point of view is straightforward.  _Objects_ can be represented as union which always have instance no. 0. 

_Enums_ are serializable by default and are written using shorthand functions for performance sake. By default, no special serializers are generated for them; however, if some specific metadata have to be recorded (e.g. special serial name for one of enum's instances), plugin is forced to generate corresponding serializer, which calls single `encodeEnumValue`.

_Polymorphic_ serialization (which kicks in if serializable class is `open`) resolve types at runtime; therefore, indices and serializers for it as union are built using registry. Consult library documentation for its usage.

### Resolving and lookup

During generation of implementation methods, compiler plugin needs to chose concrete method to call from group of `(en|de)codeXxxElement`. If current property has primitive non-nullable type, like `Int` or `String`, then it is possible to call matched by signature method directly. If it has nullable and/or complex `E`, compiler plugin uses following rules to find serializer for `E` and then call `(en|de)codeSerializableElement`:

1. If current property annotated with `@Serializable(with=T::class)`, construct and use instance of `T` as serializer for `E`.
1. If `E` is a type parameter, use corresponding serializer passed in constructor.
1. If `E` is a primitive type (boxed for some reason), use corresponding pre-defined serializer from runtime library.
2. If `E = V?` – nullable type, find serializer for `V` and adapt it with `NullableSerializer` from runtime library.
1. If `E` is on of supported types from standard library, then find serializer for its generic arguments and construct corresponding serializer from runtime library.
1. If `E` is a user type annotated with `@Serializable`, construct and use its `$serializer`.
1. If `E` is a user type annotated with `@Serializable(with=T::class)`, construct and use instance of `T` as serializer.
1. If none of the previous rules apply, report a compile-time error about unserializable field in class.

### Auto-discovering serializers for standard library types

Serializers located at `kotlinx.serialization.builtins` package can be automatically
discovered by plugin, when there are no ambiguity – for given `T`, there is only one `Serializer<T>`. Generic arguments of `T` are not taken into account.
Currently, this package contains serializers for following types: `Array, (Mutable)List, ArrayList, (Mutable)Set, LinkedHashSet, (Mutable)Map, LinkedHashMap, Pair, Triple`; all primitive types.
User-defined libraries can also make additions to this package, but use it carefully and wisely.

### Tuning generated code

To be more flexible and support various use-cases, plugin have to respect following annotations:

* `@SerialName`, which alters name of property or class written to metadata in descriptor.
* `@Optional`, which allows property to be absent in the decoder input. Requires default value on property. By default, all properties are required (even with default values).
* `@Transient`, which makes property invisible for plugin.
* `@SerialInfo`, which allows to create custom annotations with metadata and record them in the descriptor.

## Open for discussion issues

* `SerializationStrategy` and `DeserializationStrategy` aren't used as widely as `Serializer`, but still those names are long and cumbersome.
* It may be not clear that `Serializer` can do both serialization and deserialization. Maybe we need better name?
* Should user have an ability to manipulate layout and order of calls to encoder from generated code? [#121](https://github.com/Kotlin/kotlinx.serialization/issues/121)
* Should `@Optional` annotation be applied automatically when property has default value? [#19](https://github.com/Kotlin/kotlinx.serialization/issues/19)
* Should primitive arrays (ByteArray etc) be treated specially by plugin or should it be burden of format implementation to handle them? [#52](https://github.com/Kotlin/kotlinx.serialization/issues/52)

## Future work

* Implement serialization/deserialization of interfaces.
* Serializable coroutines and continuations.
