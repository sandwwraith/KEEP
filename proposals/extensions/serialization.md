# Kotlin serialization compiler plugin

* **Type**: Design proposal
* **Authors**: Roman Elizarov, Leonid Startsev, Vsevolod Tolstopyatov
* **Status**: Submitted
* **Prototype**: Partially implemented, shipped separately

## Feeback

Original proposal and its discussion are held in this [forum thread](https://discuss.kotlinlang.org/t/kotlin-serialization/2063).
A lot of feedback is gathered in the repository [issues](https://github.com/Kotlin/kotlinx.serialization/issues?q=is:issue+label:design+).

## Synopsis

Kotlin, starting from 1.2, offers support for multiplatform projects, and there is a need in multiplatform library for serialization.
Since reflection is not available in common code, auto-generated code can help to reduce big amount of boilerplate which users need to write to serialize and deserialize classes.

This proposal describes how compiler plugin can be used for this task, and offers a convention between compiler and runtime library [kotlinx.serialziation](https://github.com/Kotlin/kotlinx.serialization/). It consists of three parts: first briefly describes kotlinx.serialization framework, introduces core concepts and interfaces. Second covers code generation by plugin in details. Third reveals approaches to most common use-cases.

## Problems this proposal tries to solve

1. Platform serialization mechanisms not always work well with Kotlin: [KT-7939](https://youtrack.jetbrains.com/issue/KT-7939), [KT-23998](https://youtrack.jetbrains.com/issue/KT-23998)
1. Reflection API is not available in Kotlin/JS and Kotlin/Native, so it is impossible to use only runtime-based solution.
1. Kapt is not supported by Kotlin/JS and Kotlin/Native, so it is impossible to use annotation processing.
1. Side code generators does not work well with incremental compilation and it is non-trivial to include them as build phase.
1. kotlinx.serialization alone requires a lot of boilerplate code.

## Explicit goals of serialization framework
* Provide single abstraction over various serialization formats.
* Eliminate usage of reflection to be available on all Kotlin target platforms.
* Work with speed comparable or bigger than traditional reflection-based solutions.
* Provide mechanism for saving both class and its schema. Latter could be automatically generated from class' Kotlin source code.
* Leverage other usages of the ability to traverse class data, like hashers, ORM, or lenses.

## Core API overview and mental model

At a glance, kotlinx.serialziation tries to provide abstraction over different serialization formats by exposing API which can encode primitive types one-by-one. Compiler plugin can make proper usage of this API, since it knows everything about which fields a class consists of. In somewhat, this plugin could be equivalent to [parcelize plugin](android-parcelable.md), but for bigger API.

To support all use cases presented in corresponding section above, we make clear distinction between **serialization** process and **encoding** process. Here's our glossary:

* **Serialization** is a process of transforming one single entity to a stream of its elements. Each element is either a primitive or a complex entity, latter is transformed recursively. In the end, serializer emits a stream of primitive elements.

* **Encoding** is a processing of elements stream. In contrary to traditional definition of serialization, we don't say that encoder must write elements to some storage. It could do this (e.g. JSON encoder saves elements to string and encapsulates all knowledge about char encoding, delimiters, etc...), but it also could process stream in-memory to transform or aggregate elements.

> Inverse processes are called **deserialization** and **decoding** correspondingly.

> Source code of API given here is not full and contains only declarations which need to be stable and discoverable by code generator. Other parts of library and additional interfaces methods are not connected with plugin and therefore are not included here.

### Serializer interfaces

Following interfaces are provided in the library to be implemented by serializer of particular class:

```kotlin
interface SerializationStrategy<in T> {
    fun serialize(output: Encoder, obj : T)
    val descriptor: SerialDescriptor
}

interface DeserializationStrategy<out T> {
    fun deserialize(input: Decoder, oldValue: T?): T
    val descriptor: SerialDescriptor
}

interface Serializer<T>: SerializationStrategy<T>, DeserializationStrategy<T> {
    override val descriptor: SerialDescriptor
}
```

`Serializer<T>` is an entity that knows how to decompose class `T` and feed its primitives to some encoding/saving mechanism, and vice versa. Its implementation usually generated by compiler plugin, but can be written by user in some special cases. Note, that it should not know anything about output or storage format.

> In documentation for this framework, we are using words "serializer" and "serialization" widely. Please pay special attention that under this words, in most of cases, we assume capable entity or process of both serialization (saving, decomposing) and deserialization (loading, composing) – just because there is no good word for "both serialization and deserialization same time".

### Descriptor of serializable entity

Because reflection can't be used in this library, there is a need for some data structure sufficient to hold simple metadata about serializable class – to be able to retrieve information needed for saving both class and its schema, e.g. class name, properties names and types and so on. Interface for this data structure is provided by the library and called `SerialDescriptor`. It _describes_ **serializable entity**, or just **entity**, which has **elements**. 

```kotlin
interface SerialDescriptor {
    val name: String
    val kind: SerialKind

    fun getElementName(index: Int): String
    fun getElementIndex(name: String): Int

    fun getEntityAnnotations(): List<Annotation>
    fun getElementAnnotations(index: Int): List<Annotation>

    val elementsCount: Int

    fun getElementDescriptor(index: Int): SerialDescriptor

    val isNullable: Boolean
    fun isElementOptional(index: Int): Boolean
}
```

Corresponding documentation and usage of the interface are out of scope of this document; it is presented here to introduce general concept of serializable entity metadata. This interface can (and should) also be implemented by compiler plugin for given class, because `Serializer<T>` has reference on `SerialDescriptor`.

#### Serial kinds

Note, that we specially don't limit ourselves to "class and properties" terminology, because not only classes can be described with this data structure. `SerialKind` can give a clue on which kinds of entities can be serialized:

```kotlin
sealed class SerialKind

sealed class PrimitiveKind: SerialKind() {
    object INT : PrimitiveKind()
    object STRING: PrimitiveKind()
    // other primitives cut out for shortness
}

sealed class StructureKind: SerialKind() {
    object CLASS: StructureKind()
    object LIST: StructureKind()
    object MAP: StructureKind()
}

sealed class UnionKind: SerialKind() {
    object OBJECT: UnionKind()
    object ENUM: UnionKind()
    object SEALED: UnionKind()
    object POLYMORPHIC: UnionKind()
}
```

Under union here, we assume **tagged union**, also known as **sum type**. Its elements are its **cases**, and current element is the currently tagged case.
Although we called one of kinds `SEALED`, this kind is applicable not only to Kotlin's `sealed` classes; any bounded polymorphism (where all inheritors are known in advance, at compile-time) can be expressed via special annotation on union base class.
Open polymorphism, expressed by `POLYMORPHIC`, requires runtime registration of all known subtypes and discussed later in this document.
Difference between `ENUM` and `OBJECT` is motivated by the fact that even if enum consists of one case (and therefore is practically an object), during program evolution, it can get more cases.

Detailed invariants of `SerialDescriptor` for each kind will be described in kind's documentation. Entities which does not have primitive kind we would call **composite**.

### Encoder interfaces

Encoder encapsulates knowledge about output format and storage. This interface is provided by serialization format in runtime and should be used by serializer. For performance and type-safe reasons, encoder interface contains one method for each primitive type:

```kotlin
interface Encoder {
    fun encodeNotNullMark()
    fun encodeNull()

    fun encodeUnit()
    fun encodeBoolean(value: Boolean)
    fun encodeByte(value: Byte)
    fun encodeShort(value: Short)
    fun encodeInt(value: Int)
    fun encodeLong(value: Long)
    fun encodeFloat(value: Float)
    fun encodeDouble(value: Double)
    fun encodeChar(value: Char)
    fun encodeString(value: String)

    // although we don't classify enums as primitives in terms of kinds,
    // this function is provided as a shorthand.
    fun <E : Enum<E>> encodeEnum(value: E, enumDescriptor: SerialDescriptor)

    // can be defined as extension
    fun <T : Any?> encodeSerializable(strategy: SerializationStrategy<T>, value: T) {
        strategy.serialize(this, value)
    }
}
```

However, this interface is not able to write composite data like classes, collections or unions, because there is no way to express delimiters and metadata about entity itself. 
`CompositeEncoder` serves this purpose. It has similar to `Encoder` interface with methods which accept serializable descriptor and current position in structure or case in union. Note that it does not extend `Encoder` because once you've started to write structure, you're not allowed to write primitive values without indices.

```kotlin
interface Encoder {
    // in addition to previous methods
    fun beginEncodeComposite(desc: SerialDescriptor): CompositeEncoder
}

interface CompositeEncoder {
    // delimiter
    fun endEncodeComposite(desc: SerialDescriptor)

    /** 
     * Invoked if element equals to its default value, 
     * giving a possibility to omit it in output stream
     */
    fun shouldEncodeElementDefault(desc: SerialDescriptor, index: Int): Boolean

    fun encodeUnitElement(desc: SerialDescriptor, index: Int)
    fun encodeBooleanElement(desc: SerialDescriptor, index: Int, value: Boolean)
    fun encodeByteElement(desc: SerialDescriptor, index: Int, value: Byte)
    fun encodeShortElement(desc: SerialDescriptor, index: Int, value: Short)
    fun encodeIntElement(desc: SerialDescriptor, index: Int, value: Int)
    fun encodeLongElement(desc: SerialDescriptor, index: Int, value: Long)
    fun encodeFloatElement(desc: SerialDescriptor, index: Int, value: Float)
    fun encodeDoubleElement(desc: SerialDescriptor, index: Int, value: Double)
    fun encodeCharElement(desc: SerialDescriptor, index: Int, value: Char)
    fun encodeStringElement(desc: SerialDescriptor, index: Int, value: String)

    fun <E : Enum<E>> encodeEnumElement(desc: SerialDescriptor, index: Int, value: E, enumDescriptor: SerialDescriptor)

    fun <T> encodeSerializableElement(desc: SerialDescriptor, index: Int, strategy: SerializationStrategy<T>, value: T)
}
```

### Decoder interfaces

Decoder, as encoder, encapsulates knowledge about format, and
provides primitive values when deserializer asks for them. 
`Decoder` interface will be precisely the opposite of `Encoder`:

```kotlin
interface Decoder {
    // returns true if the following value is not null, false if not null
    fun decodeNotNullMark(): Boolean
    // consumes null, returns null, will be called when decodeNotNullMark() is false
    fun decodeNull(): Nothing?

    fun decodeUnit()
    fun decodeBoolean(): Boolean
    fun decodeByte(): Byte
    fun decodeShort(): Short
    fun decodeInt(): Int
    fun decodeLong(): Long
    fun decodeFloat(): Float
    fun decodeDouble(): Double
    fun decodeChar(): Char
    fun decodeString(): String

    // because there is no non-reflective version of `valueOf`, decoder
    // is asked for a particular index of enum instance
    fun <T : Enum<T>> decodeEnum(enumDescriptor: SerialDescriptor): Int

    // can be defined as extension
    fun <T : Any?> decodeSerializable(strategy: DeserializationStrategy<T>): T = strategy.deserialize(this)
}
```

However, an opposite interface for `ElementEncoder` would not be very useful. Primitives in read stream can go in arbitrary order, and besides opposite to `encodeXxxElement` methods there is a `decodeElementIndex` method, which should be called to determine current position in structure.

```kotlin
interface Decoder {
    fun beginDecodeComposite(desc: SerialDescriptor): CompositeDecoder
}

interface CompositeDecoder {
    fun endDecodeComposite(desc: SerialDescriptor)

    // decodeElementIndex results
    companion object {
        // end of input
        const val READ_DONE = -1
        // decoder sure that elements go in order, no need to call decodeElementIndex
        const val READ_ALL = -2
    }

    // returns either index or one of READ_XXX constants
    fun decodeElementIndex(desc: SerialDescriptor): Int

    /**
     * Optional method to specify collection size to pre-allocate memory,
     * called in the beginning of collection reading.
     * If decoder specifies stream reading ([READ_ALL] is returned from [decodeElementIndex]), then
     * correct implementation of this method is mandatory.
     *
     * @return Collection size or -1 if not available.
     */
    fun decodeCollectionSize(desc: SerialDescriptor): Int = -1

    /**
     * This method is called when [decodeElementIndex] returns index which was 
     * already encountered during deserialization of this class. 
     *
     * @throws [UpdateNotSupportedException] if this implementation 
     *                                       doesn't allow fields duplicating.
     */
    fun decodeElementAgain(desc: SerialDescriptor, index: Int): Unit

    fun decodeUnitElement(desc: SerialDescriptor, index: Int)
    fun decodeBooleanElement(desc: SerialDescriptor, index: Int): Boolean
    fun decodeByteElement(desc: SerialDescriptor, index: Int): Byte
    fun decodeShortElement(desc: SerialDescriptor, index: Int): Short
    fun decodeIntElement(desc: SerialDescriptor, index: Int): Int
    fun decodeLongElement(desc: SerialDescriptor, index: Int): Long
    fun decodeFloatElement(desc: SerialDescriptor, index: Int): Float
    fun decodeDoubleElement(desc: SerialDescriptor, index: Int): Double
    fun decodeCharElement(desc: SerialDescriptor, index: Int): Char
    fun decodeStringElement(desc: SerialDescriptor, index: Int): String

    fun <T : Enum<T>> decodeEnumElement(desc: SerialDescriptor, index: Int, enumDescriptor: SerialDescriptor): Int

    // [wasRead] is analogue to [decodeElementAgain] passed here so fast decoders
    // won't have to save it in state variable
    fun <T : Any?> decodeSerializableElement(desc: SerialDescriptor, index: Int, strategy: DeserializationStrategy<T>, oldValue: T?, wasRead: Boolean): T
}
```

## Code generation strategy

### Requirements

First, let's narrow the scope for now and say that only class or object can be serializable, not interface or annotation.

If compiler plugin has complete control over the class, then it can automatically implement `Serializer<T>` for class `T` if its every primary constructor parameter is `val` or `var` – since parameters which are not properties are impossible to save for restoring later. In this case (we called it **internal** serialization), plugin injects special synthetic constructor into the class to be able to correctly initialize its private and/or body properties. Delegated properties are not supported (they can be safely excluded from the process).

If plugin was asked to generate `Serializer<T>` without modifying `T` (**external** serialization), then class `T` must have accessible primary constructor. Following properties would be impossible to initialize correctly after deserialization and therefore they are skipped:

- private/protected body vals and vars (internal too if `T` located in other module)
- public body vals

### Layout of synthetic classes and methods for structures

In case of internal serialization, which is expressed by `@Serializable` annotation on class `T`, compiler plugin should generate:

1. Synthetic constructor for `T` which initializes all state properties including private and body ones.
1. Nested class with special name `$serializer` which implements `Serializer<T>`. If `T` has no type arguments, this class would be a singleton. If it has, e.g. `T = T<T0, T1...>` then its constructor will have properties `Serializer<T0>, Serializer<T1>, ...`.
5. Implementation property `$serializer.descriptor` which holds metadata about class.
2. Method `T.Companion.serializer()` which returns `$serializer`. If `T` has type arguments (`T = T<T0, T1...>`) then this method will have arguments `Serializer<T0>, Serializer<T1>, ...`. If companion is not declared on class, its default body also will be generated.
3. Implementation method `$serializer.serialize(Encoder, T)` which feeds T into Encoder by making consequent calls to `beginStructure`, `encodeXxxElement` several times, `endStructure`.
4. Implementation method `$serializer.deserialize(Decoder, T?): T` which collects variables from Decoder by making calls to `beginStructure`, `decodeElementIndex`, `decodeXxxElement` with correct index until end of input, `endStructure`. Then it validates that either all primitives were read or oldValue presents to get them from there, and constructs T from collected primitives.

In case of external serialization, expressed by `@ExternalSerializer(forClass=...)` only last three items are done. In `deserialize`, plugin calls primary constructor of class and then all available property setters.

User should be able to provide custom implementation for `serialize` and `deserialize` just by writing functions with proper signature by hand, in this case compiler plugin will skip corresponding steps.

### Layout for unions

For unions, plugin would do the same thing, except bodies of `serialize` and `deserialize` methods: only one `encodeSerializableElement` method is called. Index argument represents which particular instance is being serialized, and serializer for that instance is passed. _sealed classes_ serialization from this point of view is straightforward. _Objects_ can be represented as union which always have instance no. 0. 

_Enums_ are serializable by default and are written using shorthand functions for performance sake. By default, no special serializers are generated for them; however, if some specific metadata have to be recorded (e.g. special serial name for one of enum's instances), plugin is forced to generate corresponding serializer, which calls single `encodeEnumValue`.

_Polymorphic_ serialization (which kicks in if serializable class is `open`) resolve types at runtime; therefore, indices and serializers for it as union are built using registry. Consult library documentation for its usage.

### Resolving and lookup

During generation of implementation methods, compiler plugin needs to chose concrete method to call from group of `(en|de)codeXxxElement`. If current property has primitive non-nullable type, like `Int` or `String`, then it is possible to call matched by signature method directly. If it has nullable and/or complex `E`, compiler plugin uses following rules to find serializer for `E` and then call `(en|de)codeSerializableElement`:

1. If current property annotated with `@Serializable(with=T::class)`, construct and use instance of `T` as serializer for `E`.
1. If `E` is a type parameter, use corresponding serializer passed in constructor.
1. If `E` is a primitive type (boxed for some reason), use corresponding pre-defined serializer from runtime library.
2. If `E = V?` – nullable type, find serializer for `V` and adapt it with `NullableSerializer` from runtime library.
1. If `E` is on of supported types from standard library, then find serializer for its generic arguments and construct corresponding serializer from runtime library.
1. If `E` is a user type annotated with `@Serializable`, construct and use its `$serializer`.
1. If `E` is a user type annotated with `@Serializable(with=T::class)`, construct and use instance of `T` as serializer.
1. If none of the previous rules apply, report a compile-time error about unserializable field in class.

### Auto-discovering serializers for standard library types

Serializers located at `kotlinx.serialization.builtins` package can be automatically
discovered by plugin, when there are no ambiguity – for given `T`, there is only one `Serializer<T>`. Generic arguments of `T` are not taken into account.
Currently, this package contains serializers for following types: `Array, (Mutable)List, ArrayList, (Mutable)Set, LinkedHashSet, (Mutable)Map, LinkedHashMap, Pair, Triple`; all primitive types.
However, it is strongly discouraged to make user additions to this package.

### Auto-discovering user-defined external serializers

To give compiler plugin a hint about external serializer, annotation `@Serializable(with: KClass<*>)` can be applied on property. However, it can be boilerplate-ish to annotate every property if you have a big number of domain classes which have to use, e.g. external serializer for `java.util.Date`.
For this purpose, annotation `@Serializers(vararg s: KSerializer<*>)` was introduced. It can be applied to a class or even to a file and adds given serializers to the scope of compiler plugin.

### Tuning generated code

To be more flexible and support various use-cases, plugin have to respect following annotations:

* `@SerialName`, which alters name of property or class written to metadata in descriptor. Can also be applicable to enum cases.
* `@Optional`, which allows property to be absent in the decoder input. Requires default value on property. By default, all properties are required (even with default values).
* `@Transient`, which makes property invisible for plugin.
* `@SerialInfo`, which allows to create custom annotations with metadata and record them in the descriptor.

## Pre-designed use-cases

### Saving schemas with descriptor

Serial descriptors have some important features. One of them is that they must provide access to all elements' descriptors via `getElementDescriptor`, giving us possibility to look on them as on tree-like structure. This allows schema traversing and saving. Using that information, descriptors must provide correct `equals` and `hashCode`, giving us a feature to cache schema in a hashmap once it's computed.

### Optionality in details

Handling optional properties during deserialization is easy – compiler just generates bit mask for validation, similar to how default values in functions are compiled. However, one of the most popular feature request for library was omitting default values during serialization. For this purpose, method `shouldEncodeElementDefault` in `CompositeEncoder` was introduced. For every optional property, compiler emits following construction:

```kotlin
// let's say we recording "i" from following class definition:
// @Serializable class Data(val s: String, @Optional val i: Int = 42)
if (obj.i == 42 && output.shouldEncodeElementDefault(this.descriptor, 1))
    output.encodeIntElement(this.descriptor, 1, obj.i)
```

With this code, decision whether to encode default value is passed to encoder and therefore to its storage format. Some formats may have this setting as boolean option (e.g. JSON), some formats always need value (e.g. hasher), some of them will rely on additional information in descriptor to make this decision.

### Reading values twice — updating, overwriting or banning

To ease detection of element duplicates in input stream, method `CompositeDecoder.decodeElementAgain` is provided. This method servers purely indicating purposes and can't alter other calls to decoder or skip them.
To abort the process, decoder implementation can throw an exception. If implementation supports overwrite/merge, it is ok to do nothing.
If this method returns normally, deserialization process 
continues as usual (including calling decodeSomething with given index). 
Primitives can't be merged and therefore they are overwritten by consequent calls to decodeSomething. Complex values are decoded via `decodeSerializableElement(desc: SerialDescriptor, index: Int, strategy: DeserializationStrategy<T>, oldValue: T?, wasRead: Boolean)` and it's implementation burden to analyze `wasRead` flag and decide whether to use `oldValue` to merge it with current stream via passing it to corresponding `.deserialize()` or to just ignore it.

### Contextual serialization

By default, all serializers are resolved by plugin statically when compiling serializable class. This gives us type-safety, performance and eliminates reflection usage to minimum. However, in certain cases one may want to delay serializers resolving to runtime. One of such cases is where you want to define two different serializers for different formats, say serializing `Date` differently in JSON and XML. To support such cases, a concepts of `SerialContext` and `ContextSerializer` were introduced. Roughly speaking, it's a map where runtime part of framework is looking for serializers if they weren't resolved at compile time by plugin.

To enable its usage, annotate property with `@SerializableWith(ContextSerializer::class)` or `@ContextualSerialization`. Latter annotation can also be applied at file-level in form `@ContextualSerialization(vararg classes: KClass)`. `ContextSerializer` captures `KClass` of the property and later looks for assigned to it serializer.

`SerialContext` is available as `val context` in encoders and decoders. It contains function `.getContextualSerializer(forClass: KClass)` which is used by `ContextSerializer`. However, it does not contain functions to register serializers.

`interface MutableSerialContext : SerialContext` can be exposed by high-level abstractions (e.g. concrete JSON format, which can encapsulate a bunch of encoders) and provides ability to correctly register all serializers. 

These concepts will be described more precisely in runtime library's documentation.

### Polymorphism

Usually, polymorphism usage in serialization is discouraged due to its security problems. But writing complex business logic is almost impossible without this main OOP feature.
In our design for this framework, we've tried to get rid of 'deserialize-anything' problem by several requirements. First of them is that all serializable implementations of some abstract class must be registered in advance. It also helps to remove reflection usage, such as `Class.forName`, that made polymorphism unavailable on Kotlin/JS.
This is more permissive approach than 'bounded polymorphism' described in section next to `SerialKind.SEALED`, because it allows registering subclasses in runtime, not compile-time. For example, it allows to add to registry additional subclasses that were defined in separate module, dependent on base one with base class.

Role of such registry can be taken by already discussed `SerialContext`. This also limits which polymorphic classes can be deserialized by which formats/wires.

Polymorphic serialization never enables automatically. To enable this feature, use `@SerializableWith(PolymorphicSerializer::class)` or just `@Polymorphic` on property.

Another security limit here is we allow to register subclasses only in scope of some base class, called _basePolyType_. Motivation for this is easily understandable from the example:

```kotlin
abstract class BaseRequest()
@Serializable data class RequestA(val id: Int): BaseRequest()
@Serializable data class RequestB(val s: String): BaseRequest()

abstract class BaseResponse()
@Serializable data class ResponseC(val payload: Long): BaseResponse()
@Serializable data class ResponseD(val payload: ByteArray): BaseResponse()

@Serializable data class Message(
    @Polymorphic val request: BaseRequest,
    @Polymorphic val response: BaseResponse
)
```

In this example both `request` and `response` in `Message` are serializable with `PolymorphicSerializer` due to annotation on them; `BaseRequest` and `BaseResponse` became _basePolyType_ s. (they are not required to be serializable by themselves).
Yet `PolymorphicSerializer` for `request` should only contain mappings to `RequestA` and `RequestB` serializers, and none of response's serializers. This is achieved through special form of `registerPolymorphicSerializer` function, which accepts two kClasses: `registerPolymorphicSerializer(basePolyType: KClass, concreteClass: KClass, serializer: KSerializer = concreteClass.serializer())`.

For details about registering and usage of pre-defined _modules_, consult library's documentation.

## Open for discussion issues

* `SerializationStrategy` and `DeserializationStrategy` aren't used as widely as `Serializer`, but still those names are long and cumbersome.
* It may be not clear that `Serializer` can do both serialization and deserialization. Maybe we need better name?
* Should user have an ability to manipulate layout and order of calls to encoder from generated code? [#121](https://github.com/Kotlin/kotlinx.serialization/issues/121)
* Should `@Optional` annotation be applied automatically when property has default value? [#19](https://github.com/Kotlin/kotlinx.serialization/issues/19)
* Should primitive arrays (ByteArray etc) be treated specially by plugin or should it be burden of format implementation to handle them? [#52](https://github.com/Kotlin/kotlinx.serialization/issues/52)
* How to support different class name representations for different formats in polymorphism? [#168](https://github.com/Kotlin/kotlinx.serialization/issues/168)
* Should polymorphic serializer omit class name in trivial cases (primitives)? [#40](https://github.com/Kotlin/kotlinx.serialization/issues/40)

## Future work

* Implement serialization/deserialization of interfaces.
* Serializable coroutines and continuations.
